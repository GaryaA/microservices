# Summary: Section 2 - Building Microservices using Spring Boot

## Обзор секции

Во второй секции курса изучалось создание микросервисов с использованием Spring Boot. Были созданы три независимых микросервиса для банковского приложения EazyBank: Accounts (Счета), Cards (Карты) и Loans (Кредиты).

## Что было изучено

### 1. Архитектура микросервисов
- Создание независимых микросервисов с собственными базами данных
- Разделение ответственности между сервисами
- Каждый микросервис работает на отдельном порту и имеет свою базу данных
- **Важно**: На этом этапе микросервисы НЕ общаются между собой - они полностью независимы и работают изолированно

### 2. Spring Boot основы
- **Версия**: Spring Boot 3.4.1 с Java 21
- Настройка Spring Boot приложений с использованием Maven
- Использование Spring Boot Starter зависимостей:
  - `spring-boot-starter-web` - для создания REST API
  - `spring-boot-starter-data-jpa` - для работы с базой данных
  - `spring-boot-starter-validation` - для валидации данных
  - `spring-boot-starter-actuator` - для мониторинга и управления приложением

### 3. Работа с базой данных
- Использование H2 in-memory базы данных для разработки
- Создание схемы базы данных через SQL скрипты (`schema.sql`)
- Настройка JPA через `application.yml`
- Использование Spring Data JPA репозиториев для работы с данными

### 4. JPA и Entity модели
- Создание JPA Entity классов (`@Entity`, `@Table`)
- Использование `@MappedSuperclass` для базовых классов (`BaseEntity`)
- Реализация JPA Auditing:
  - `@EnableJpaAuditing` в главном классе приложения
  - `@CreatedDate`, `@CreatedBy`, `@LastModifiedDate`, `@LastModifiedBy`
  - Кастомная реализация `AuditorAware` для отслеживания автора изменений

### 5. DTO (Data Transfer Object) паттерн
- Разделение Entity и DTO классов
- Использование DTO для передачи данных между слоями
- Валидация данных на уровне DTO с помощью Bean Validation:
  - `@NotEmpty`, `@Size`, `@Email`, `@Pattern`
  - Кастомные сообщения об ошибках валидации

### 6. Mapper классы
- Ручное создание Mapper классов для преобразования между Entity и DTO
- Статические методы для маппинга в обе стороны
- Примеры: `CustomerMapper`, `AccountsMapper`, `CardsMapper`, `LoansMapper`

### 7. REST API разработка
- Создание REST контроллеров с `@RestController`
- Реализация CRUD операций:
  - **CREATE** - `@PostMapping` для создания новых записей
  - **READ** - `@GetMapping` для получения данных
  - **UPDATE** - `@PutMapping` для обновления данных
  - **DELETE** - `@DeleteMapping` для удаления данных
- Использование правильных HTTP статус кодов (200, 201, 400, 404, 417, 500)
- Настройка `produces = MediaType.APPLICATION_JSON_VALUE`

### 8. Валидация и обработка ошибок
- Валидация входных параметров с `@Valid` и `@Validated`
- Глобальная обработка исключений через `@ControllerAdvice`
- Создание кастомных исключений:
  - `ResourceNotFoundException` - для ресурсов, которые не найдены
  - `CustomerAlreadyExistsException` - для дублирующихся записей
- Обработка `MethodArgumentNotValidException` для валидационных ошибок
- Создание структурированных ответов об ошибках (`ErrorResponseDto`)

### 9. OpenAPI/Swagger документация
- Интеграция SpringDoc OpenAPI для автоматической генерации документации
- Настройка `@OpenAPIDefinition` с метаданными API
- Использование аннотаций:
  - `@Tag` - для группировки API endpoints
  - `@Operation` - для описания операций
  - `@ApiResponses` - для документирования возможных ответов
  - `@Schema` - для описания моделей данных

### 10. Lombok
- Использование Lombok для уменьшения boilerplate кода:
  - `@Data` - генерация геттеров, сеттеров, toString, equals, hashCode
  - `@AllArgsConstructor`, `@NoArgsConstructor` - конструкторы
  - `@Getter`, `@Setter` - отдельные аннотации
  - `@ToString` - генерация toString метода

### 11. Структура проекта
- Организация кода по пакетам:
  - `controller` - REST контроллеры
  - `service` и `service.impl` - бизнес-логика
  - `repository` - доступ к данным
  - `entity` - JPA сущности
  - `dto` - объекты передачи данных
  - `mapper` - классы для преобразования
  - `exception` - кастомные исключения
  - `constants` - константы приложения
  - `audit` - аудит функциональность

## Межсервисная коммуникация

**Во 2-й секции микросервисы НЕ общаются между собой.**

На этом этапе курса создаются базовые независимые микросервисы, которые:
- Работают изолированно друг от друга
- Имеют собственные REST API endpoints
- Не знают о существовании других микросервисов
- Не используют никаких механизмов межсервисной коммуникации (нет Feign, RestTemplate, WebClient)

**Межсервисная коммуникация будет изучена позже:**
- **Section 8** - Service Discovery и OpenFeign для синхронной коммуникации
- **Section 13-14** - Event-driven архитектура с RabbitMQ/Kafka для асинхронной коммуникации

## Что было реализовано

### Микросервис Accounts (Счета)
- **Порт**: 8080
- **Функциональность**:
  - Создание нового клиента и счета
  - Получение информации о клиенте и счете по номеру телефона
  - Обновление данных клиента и счета
  - Удаление клиента и счета
- **Сущности**: `Customer`, `Accounts`
- **Особенности**: Автоматическая генерация номера счета при создании

### Микросервис Cards (Карты)
- **Порт**: 9000
- **Функциональность**:
  - Создание новой карты по номеру телефона
  - Получение информации о карте
  - Обновление данных карты
  - Удаление карты
- **Сущности**: `Cards`

### Микросервис Loans (Кредиты)
- **Порт**: 8090
- **Функциональность**:
  - Создание нового кредита по номеру телефона
  - Получение информации о кредите
  - Обновление данных кредита
  - Удаление кредита
- **Сущности**: `Loans`

## Технические детали

### Зависимости проекта
- Spring Boot 3.4.1
- Java 21
- H2 Database (in-memory)
- SpringDoc OpenAPI 2.8.1
- Lombok
- Spring Boot DevTools

### Конфигурация
- Использование `application.yml` для конфигурации
- Настройка портов серверов
- Конфигурация H2 консоли для разработки
- Настройка JPA и Hibernate

### Best Practices
- Разделение слоев (Controller → Service → Repository)
- Использование интерфейсов для сервисов
- DTO паттерн для изоляции внутренней модели данных
- Централизованная обработка исключений
- Валидация на уровне контроллера
- Документирование API через OpenAPI
- Аудит изменений через JPA Auditing

## Результаты секции

После завершения второй секции студенты:
1. Умеют создавать микросервисы с нуля используя Spring Boot
2. Понимают архитектуру многослойного приложения
3. Знают, как работать с JPA и базами данных в Spring Boot
4. Умеют создавать REST API с полным CRUD функционалом
5. Понимают важность валидации и обработки ошибок
6. Умеют документировать API с помощью OpenAPI/Swagger
7. Применяют best practices для организации кода в микросервисах

## Следующие шаги

В следующих секциях курса будут изучены:
- Правильное определение границ микросервисов (Section 3)
- Контейнеризация с Docker (Section 4)
- Управление конфигурациями (Section 6)
- Service Discovery (Section 8)
- API Gateway (Section 9)
- И другие продвинутые темы микросервисной архитектуры

